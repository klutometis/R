* Iterating down a list in R
  See e.g. [[file:/usr/local/src/R/src/main/util.c][util.c]]:

  #+BEGIN_SRC c
    while( n-- > 0 ) {
      if (s == R_NilValue)
        error(_("'nthcdr' list shorter than %d"), n);
      s = CDR(s);
     }    
  #+END_SRC
* TODO Vectors or lists?
  Here's the hierarchy of vector-types:

  #+BEGIN_SRC c
    /* If a non-vector argument was encountered (perhaps a list if */
    /* recursive is FALSE) then we must return a list.    Otherwise, */
    /* we use the natural coercion for vector types. */
    
    mode = NILSXP;
    if (data.ans_flags & 512)    mode = EXPRSXP;
     else if (data.ans_flags & 256) mode = VECSXP;
     else if (data.ans_flags & 128) mode = STRSXP;
     else if (data.ans_flags &  64) mode = CPLXSXP;
     else if (data.ans_flags &  32) mode = REALSXP;
     else if (data.ans_flags &  16) mode = INTSXP;
     else if (data.ans_flags & 2) mode = LGLSXP;
     else if (data.ans_flags & 1) mode = RAWSXP;
  #+END_SRC

  They seem to be talking about VECSXP as a list (the so-called "new
  list") as opposed to vectors of lower types. Maybe it makes sense,
  therefore, to translate the former as lists; latter, vectors.

  What about EXPRSXP? From [[http://cran.r-project.org/doc/manuals/R-ints.html][internals]]: "Expressions are of type
  EXPRSXP: they are a vector of (usually language) objects most often
  seen as the result of parse()."

  So: VECSXPs as lists; STR-, CPLX-, REAL-, INT- and LGLSXPs as
  vectors (maybe alternatively as lists, if dealing with vectors is
  too cumbersome).

  Indeed:

  #+BEGIN_SRC c
    if (mode == VECSXP || mode == EXPRSXP) {
      if (!recurse) {
        while (args != R_NilValue) {
          ListAnswer(CAR(args), 0, &data, call);
          args = CDR(args);
        }
      }
      else ListAnswer(args, recurse, &data, call);
      data.ans_length = length(ans);
     }
     else if (mode == STRSXP)
       StringAnswer(args, &data, call);
     else if (mode == CPLXSXP)
       ComplexAnswer(args, &data, call);
     else if (mode == REALSXP)
       RealAnswer(args, &data, call);
     else if (mode == RAWSXP)
       RawAnswer(args, &data, call);
     else if (mode == LGLSXP)
       LogicalAnswer(args, &data, call);
     else /* integer */
       IntegerAnswer(args, &data, call);    
  #+END_SRC
* TODO Embedded R
  [[http://rpy.sourceforge.net/rpy2/doc-2.3/html/introduction.html][rpy2]] has =robjects=, which does lookup on =.globalEnv=. Has a
  callable R-vector type; allows calling of arbitrary R code. The
  ``R singleton.'' There's =r_repr=: R-representation? Deals with
  the specific vector-types.

  Have to call on vectors:

  #+BEGIN_EXAMPLE
    >>> rsum = robjects.r['sum']
    >>> rsum(robjects.IntVector([1,2,3]))[0]
    6L    
  #+END_EXAMPLE

  Passes keyword arguments:

  #+BEGIN_EXAMPLE
    >>> rsort = robjects.r['sort']
    >>> res = rsort(robjects.IntVector([1,2,3]), decreasing=True)
    >>> print(res.r_repr())
    c(3L, 2L, 1L)
  #+END_EXAMPLE

  Has a specific =r.X11()= call; there's a whole spiel about
  processing interactive events; they talk about that a little [[http://cran.r-project.org/doc/manuals/R-exts.html#Meshing-event-loops][here]].

  It looks like the example code deals a lot with special
  vector-types.

  There's mechanisms for accessing fields:

  #+BEGIN_EXAMPLE
    >>> print(lm_D9.names)
     [1] "coefficients"  "residuals"     "effects"       "rank"
     [5] "fitted.values" "assign"        "qr"            "df.residual"
     [9] "contrasts"     "xlevels"       "call"          "terms"
    [13] "model"
  #+END_EXAMPLE

  A lot of invocation of the R-singleton:

  #+BEGIN_EXAMPLE
    import rpy2.robjects as robjects

    r = robjects.r

    m = r.matrix(r.rnorm(100), ncol=5)
    pca = r.princomp(m)
    r.plot(pca, main="Eigen values")
    r.biplot(pca, main="biplot")
  #+END_EXAMPLE

  Importing packages:

  #+BEGIN_EXAMPLE
    from rpy2.robjects.packages import importr

    base     = importr('base')
    stats    = importr('stats')
    graphics = importr('graphics')

    m = base.matrix(stats.rnorm(100), ncol = 5)
    pca = stats.princomp(m)
    graphics.plot(pca, main = "Eigen values")
    stats.biplot(pca, main = "biplot")
  #+END_EXAMPLE

  It assigns variables to the imported packages so that you can
  reference shit.

  [[http://rpy.sourceforge.net/rpy2/doc-2.3/html/robjects_rinstance.html][The instance of R]]; on which: call arbitrary code, too:

  #+BEGIN_EXAMPLE
    >>> print(robjects.r('1+2'))
    [1] 3
    >>> sqr = robjects.r('function(x) x^2')
    >>> print(sqr)
    function (x)
    x^2
    >>> print(sqr(2))
    [1] 4
  #+END_EXAMPLE

  Something about an R-representation:

  #+BEGIN_QUOTE
  The astute reader will quickly realize that R objects named by
  python variables can be plugged into code through their R
  representation:

  #+BEGIN_EXAMPLE
    >>> x = robjects.r.rnorm(100)
    >>> robjects.r('hist(%s, xlab="x", main="hist(x)")' %x.r_repr())
  #+END_EXAMPLE
  #+END_QUOTE

  [[http://rpy.sourceforge.net/rpy2/doc-2.3/html/robjects_environments.html][Assigning to environment]]:

  #+BEGIN_EXAMPLE
    >>> robjects.r.ls(globalenv)
    >>> robjects.globalenv["a"] = 123
    >>> print(robjects.r.ls(globalenv))
  #+END_EXAMPLE

  Oh, shit: [[http://rpy.sourceforge.net/rpy2/doc-2.3/html/robjects_formulae.html][formulae]]; [[http://rpy.sourceforge.net/rpy2/doc-2.3/html/robjects_oop.html][fucking OO]]; [[http://rpy.sourceforge.net/rpy2/doc-2.3/html/vector.html][specialized vectors]], along with
  subsetting. Specialized =NA=, too. Special-casing operators, too.
  =DataFrame=.

  [[http://rpy.sourceforge.net/rpy2/doc-2.3/html/robjects_convert.html][Type-conversion]] between R <-> Python: =ri2py=, =py2ri=, =py2ro=,
  &c. [[http://rpy.sourceforge.net/rpy2/doc-2.3/html/graphics.html][Graphics]] require special handling. [[http://rpy.sourceforge.net/rpy2/doc-2.3/html/interactive.html][Interactive]].

  [[http://rpy.sourceforge.net/rpy2/doc-2.3/html/rinterface.html][Low-level interface]]: =initr=, =endr=, &c. =globalenv=, =baseenv=,
  &c.

  Oh, shit:

  #+BEGIN_QUOTE
  Rpy2 is using its own reference counting system in order to bridge
  R with Python and keep the pass-by-reference approach familiar to
  Python users.
  #+END_QUOTE

  Calling Python from R:

  #+BEGIN_QUOTE
  As could be expected from Râ€™s functional roots, functions are
  first-class objects. This means that the use of callback functions
  as passed as parameters is not seldom, and this also means that
  the Python programmer has to either be able write R code for
  functions as arguments, or have a way to pass Python functions to
  R as genuine R functions. That last option is becoming possible,
  in other words one can write a Python function and expose it to R
  in such a way that the embedded R engine can use as a regular R
  function.
  #+END_QUOTE

  They have support for closures; [[http://rpy.sourceforge.net/rpy2/doc-2.3/html/rinterface.html#index-19][enumeration of R-types]]. Don't
  forget about [[http://rpy.sourceforge.net/rpy2/doc-2.3/html/server.html#][Rserve]].

  [[http://rpy.sourceforge.net/rpy/doc/rpy_html/Invocation.html#Invocation][rpy]] looks less magical; [[http://rpy.sourceforge.net/rpy/doc/rpy_html/R-objects-look-up.html#R-objects-look-up][name-munging]]; [[http://rpy.sourceforge.net/rpy/doc/rpy_html/Methods-of-Robj-type.html#Methods-of-Robj-type][awkward calling]]; [[http://rpy.sourceforge.net/rpy/doc/rpy_html/Sequence-protocol.html#Sequence-protocol][slices are
  not supported]]; [[http://rpy.sourceforge.net/rpy/doc/rpy_html/R-to-Python.html#R-to-Python][conversions]]; [[http://rpy.sourceforge.net/rpy/doc/rpy_html/No-conversion.html#No-conversion][Robj object]]; 

  [[http://www.omegahat.org/RSPython/overview.pdf][RSPython]] looks lower-level and possibly simpler; is it a good
  candidate for emulation? Heh: they did the [[http://www.omegahat.org/RSPython/PythonFromR.pdf][reverse]] with a
  =.Python= form in R.

  Ah: the [[http://www.omegahat.org/RSPython/Conversion.pdf][customizable convertes]] you see in =rpy=, too.

  They also [[file:/usr/local/src/RSPython/src/RCall.c][count references]], apparently; [[file:/usr/local/src/RSPython/inst/Python/RS.py][RS.py]] is refreshingly (or
  deceptively) simple. (The whole thing is packaged as an R-package,
  by the way.)

  Here's [[file:/usr/local/src/RSPython/src/PythonCall.c][some meat]]; see:

  #+BEGIN_QUOTE
  This handles calling R from Python.

  This code is quickly thrown together for the purposes of a)
  learning about the Python internals and C API, and b) to
  illustrate to others how one might embed R in Python or other
  applications and programming environments.

  There is a lot more to come, specifically the ability to be able
  to pass Python objects to R by "reference" and have R operate on
  these by calling methods in those objects that result in calls to
  Python functions/methods.
  #+END_QUOTE

  Interesting:

  #+BEGIN_QUOTE
  This is the routine that implements Python calling an S function
  with a simple, ordered list of arguments (i.e. no named S
  arguments, etc.). This converts the Python arguments into S
  objects.

  This gets 4 arguments:
    1) the name of the function to call
    2) the un-named arguments as a Tuple
    3) the named arguments (that do not use ``reserved'' words)
    4) a convert argument.    
  #+END_QUOTE

  [[http://cran.r-project.org/doc/manuals/R-exts.html#Attributes][Install]] pops things in the symbol-table, incidentally.

  #+BEGIN_SRC c :tangle Reval.h
    #include <chicken.h>

    C_word Reval(char* function, C_word args);

  #+END_SRC

  #+BEGIN_SRC c :tangle Reval.c
    #include <assert.h>
    #include <string.h>
    
    #include <Rinternals.h>
    #include <Rdefines.h>
    #include <Rembedded.h>
    
    #include <chicken.h>
    
    SEXP toR(C_word arg) {
      if (C_truep(C_i_flonump(arg))) {
        return ScalarReal(C_flonum_magnitude(arg));
      } else if (C_truep(C_fixnump(arg))) {
        return ScalarInteger(C_num_to_int(arg));
      } else if (C_truep(C_booleanp(arg))) {
        return ScalarLogical(C_truep(arg) ? 1 : 0);
      } else if (C_truep(C_stringp(arg))) {
        return ScalarString(Rf_mkChar(C_string_or_null(arg)));
      } else if (C_truep(C_vectorp(arg))) {
        /* Is this where we need to type the vector; or can we just
           VECSXP? We probably need to type the vector. Can we stick e.g.
           STRSXP in an INTSXP, though?
    
           See e.g. getListElementType in RPythonConverters.c; see also
           do_c_dflt in bind.c. What about calling the actual R function?
           It's too bad do_c or do_c_dflt aren't exposed in
           Rinternals.h.
    
           The call to R is slower, but guaranteed to be semantically
           correct. */
        int length = C_unfix(C_i_vector_length(arg));
        SEXP c = allocVector(LANGSXP, length + 1);
        SEXP ci = c;
        SETCAR(c, Rf_findFun(Rf_install("c"), R_GlobalEnv));
        int i;
        for (i = 0; i < length; i++) {
          ci = CDR(ci);
          SETCAR(ci, toR(C_i_vector_ref(arg, C_fix(i))));
        }
        int error = 0;
        return R_tryEval(c, R_GlobalEnv, &error);
      } else if (C_truep(C_pointerp(arg))) {
        return *((SEXP *) C_c_pointer_or_null(arg));
      }
      /* What the fuck is this, if not above? There should be some
         symmetry: if I don't know what the hell it is, it's a pointer
         (and vice versa). */
      return R_NilValue;
    }
    
    C_word *to_real(SEXP arg, int i) {
      C_word *value = C_alloc(C_SIZEOF_FLONUM);
      C_flonum(&value, REAL(arg)[i]);
      return value;
    }
    
    void Reval(C_word c, C_word self, C_word k, C_word name, C_word args) {
      int nargs = C_num_to_int(C_i_length(args));
      SEXP expression = allocVector(LANGSXP, nargs + 1);
      /* Have to check this for R_NilValue; see e.g. RNamedCall.c. */
      SEXP function = Rf_findFun(Rf_install(C_c_string(name)), R_GlobalEnv);
    
      SETCAR(expression, function);
      SEXP iterexp = CDR(expression);
    
      while (!C_truep(C_i_nullp(args))) {
        SETCAR(iterexp, toR(C_i_car(args)));
        args = C_i_cdr(args);
        iterexp = CDR(iterexp);
      }
    
      int error = 0;
      SEXP Rvalue = R_tryEval(expression, R_GlobalEnv, &error);
      if (!error) {
        switch (TYPEOF(Rvalue)) {
        case REALSXP:
          {
            int length = Rf_length(Rvalue);
            if (length == 1) {
              C_word *value = C_alloc(C_SIZEOF_FLONUM);
              C_kontinue(k, C_flonum(&value, REAL(Rvalue)[0]));
            } else {
              C_word *v = C_alloc(C_SIZEOF_VECTOR(length)),
                *v0 = v;
              *(v++) = C_VECTOR_TYPE | length;
              int i;
              for (i = 0; i < length; i++) {
                /* C_word *value = C_alloc(C_SIZEOF_FLONUM); */
                /* *(v++) = C_flonum(&value, REAL(Rvalue)[i]); */
                /* We're going to have to make a continuation and do CPS
                   for this to work; should we try the Schemely way
                   first? */
                *(v++) = *to_real(Rvalue, i);
              }
              C_kontinue(k, (C_word) v0);
            }
          }
        case INTSXP:
          {
            int length = Rf_length(Rvalue);
            if (length == 1) {
              C_kontinue(k, C_fix(INTEGER(Rvalue)[0]));
            } else {
              C_word *v = C_alloc(C_SIZEOF_VECTOR(length)),
                *v0 = v;
              *(v++) = C_VECTOR_TYPE | length;
              int i;
              for (i = 0; i < length; i++)
                *(v++) = C_fix(INTEGER(Rvalue)[i]);
              C_kontinue(k, (C_word) v0);
            }
          }
        case LGLSXP:
          {
            int length = Rf_length(Rvalue);
            if (length == 1) {
              C_kontinue(k, LOGICAL(Rvalue)[0] ? C_SCHEME_TRUE : C_SCHEME_FALSE);
            } else {
              C_word *v = C_alloc(C_SIZEOF_VECTOR(length)),
                *v0 = v;
              *(v++) = C_VECTOR_TYPE | length;
              int i;
              for (i = 0; i < length; i++)
                *(v++) = LOGICAL(Rvalue)[i] ?
                  C_SCHEME_TRUE : C_SCHEME_FALSE;
              C_kontinue(k, (C_word) v0);
            }
          }
        case STRSXP:
          {
            int length = Rf_length(Rvalue);
            if (length == 1) {
              const char *string = CHAR(STRING_ELT(Rvalue, 0));
              C_word *value = C_alloc(C_SIZEOF_STRING(strlen(string)));
              C_kontinue(k, C_string(&value, strlen(string), (char *) string));
            } else {
              C_word *v = C_alloc(C_SIZEOF_VECTOR(length)),
                *v0 = v;
              *(v++) = C_VECTOR_TYPE | length;
              int i;
              for (i = 0; i < length; i++) {
                const char *string = CHAR(STRING_ELT(Rvalue, i));
                C_word *value = C_alloc(C_SIZEOF_STRING(strlen(string)));
                *(v++) = C_string(&value, strlen(string), (char *) string);
              }
              C_kontinue(k, (C_word) v0);
            }
          }
        case VECSXP:
          {
            int length = Rf_length(Rvalue);
            C_word *l = C_alloc(C_SIZEOF_LIST(length + 1)),
              *l0 = l;
            int i = 0;
            for (i = 0; i < length; i++) {
              *(l++) = C_PAIR_TYPE | (C_SIZEOF_PAIR - 1);
              /* This is where we get into trouble without being able to
                 recurse into to_scheme. */
              /* *(l++) = CAR(Rvalue); */
              *(l++) = C_fix(1);
              Rvalue = CDR(Rvalue);
            }
            *(l++) = C_SCHEME_END_OF_LIST;
            C_kontinue(k, (C_word) l0);
          }
        default:
          {
            C_word *pointer = C_alloc(C_SIZEOF_POINTER);
            /* We probably need to allocate a new structure, copy Rvalue
               thither, and free at some point; don't we? Or at least
               protect the value?
    
               PROTECT and UNPROTECT preserve within calls, while
               R_PreserveObject and R_ReleaseObject preserve past calls;
               see:
               <http://r.789695.n4.nabble.com/R-PreserveObject-R-ReleaseObject-reference-counting-needed-td997167.html>*/
            C_kontinue(k, C_mpointer(&pointer, &Rvalue));
          }
        }
      }
      C_kontinue(k, C_SCHEME_UNDEFINED);
    }
    
  #+END_SRC

  #+BEGIN_SRC scheme :tangle R-test.scm
    (use debug dollar lolevel miscmacros test)
    
    #>
    #include "Reval.h"
    #include <Rembedded.h>
    <#
    
    (foreign-code
     #<<END
     Rf_initEmbeddedR(4, (char*[]) {"R-test",
                                    "--slave",
                                    "--vanilla",
                                    "--args"}) ;
    END
    )
    
    (define Reval (##core#primitive "Reval"))
    
    ;;; We should avoid this trick and just use varargs.
    (define (R-eval f . args)
      (Reval f args))
    
    ;;; Yikes: this segfaults; should we check for whether there's a valid
    ;;; representation of something? What happens when the coercion fails?
    ;;;
    ;;; No, it's merely failing on VECSXP.
    ;; (debug (R-eval "c" 2 "harro" 2.1 #f #t (R-eval "new.env")))
    ;;; This doesn't, however.
    (debug (R-eval "c" 2 "harro" 2.1 #f #t (R-eval "c" 2)))
    (debug (R-eval "rep" 2 10))
    (debug (R-eval "rep" 2.1 10))
    (debug (R-eval "rep" #t 10))
    (debug (R-eval "rep" #f 10))
    (debug (R-eval "rep" "harro" 10))
    (debug (R-eval "c" 2.023989823989823))
    (debug (R-eval "c" 1))
    (debug (R-eval "c" 2))
    (debug (R-eval "c" 3))
    (debug (R-eval "c" "harro"))
    (debug (R-eval "c" '#(10 11)))
    (debug (R-eval "list" "harro" "yes"))
    (let ((env (R-eval "new.env")))
      (R-eval "print" env))
    
  #+END_SRC

  #+BEGIN_SRC makefile :tangle R-test.mk :shebang #!/usr/bin/unexpand -t 4
    R_FLAGS := $(shell R CMD config --cppflags) \
        $(shell R CMD config --ldflags)

    CHICKEN_FLAGS := $(shell csc -cflags -ldflags -libs)

    all: R-test

    Reval.o: Reval.c
        gcc $(R_FLAGS) $(CHICKEN_FLAGS) -c -o $@ $^

    R-test: Reval.o R-test.scm
        csc $(R_FLAGS) -o $@ $^      
  #+END_SRC

  Keep [[file:/usr/local/lib64/R/include/Rinternals.h][Rinternals.h]] handy: there's good stuff in there about types,
  &c. Not to mention the [[http://cran.r-project.org/doc/manuals/R-ints.html][R internals]] doc. [[file:/usr/local/lib64/R/include/Rdefines.h][Rdefines.h]] has stuff like
  =NEW_NUMERIC=, by the way.

  There's a missing argument marker:

  #+BEGIN_SRC c
    LibExtern SEXP  R_MissingArg;       /* Missing argument marker */
  #+END_SRC

  Do we need to have a special symbol, e.g. =*missing*=? Named
  variables have to be handled, too. See e.g. keywords and kvlists.

  Can we create a SEXP in Scheme before we pass it to R, and
  UNPROTECT it in the destructor? I wonder if we'll have impedence
  mismatch between R and Scheme GC. God, I hope not. Or can we pass
  primitive types to see and do the primitive -> SEXP calculus in C?

  Look at the [[http://wiki.call-cc.org/eggref/4/lua][lua egg]], by the way, for a good, basic, thoughtful
  API; cf. [[http://wiki.call-cc.org/eggref/4/bind][bind]] and [[http://wiki.call-cc.org/eggref/4/dollar][dollar]]. Lua doesn't drop into C at all, it's
  all-dollar. Ah, it's all in the associated =.c= and =.h= files;
  wait: that's the entirety of Lua? Wow. =lua-main.scm= is
  beautiful, but maybe that's because Lua was built from the ground
  up as an embeddable. R, maybe not so much. Can be coerced, though.

  Can we confine the complexities of e.g. =SEXP= to embedded C; or
  do we have to go through the whole =define-foreign-record-type=
  rigmarole?

  See [[file:/usr/local/src/RSPython/src/RPythonConverters.c][RPythonConverters.c]], incidentally, for some conversion
  goodness. [[file:/usr/local/src/RSPython/inst/include/RSCommon.h][Mother-fuckers]]:

  #+BEGIN_SRC c
    typedef SEXP USER_OBJECT_;
  #+END_SRC

  Uses =getListElementType= to simplify to vectors when there are
  homogenous datatypes; we can just use native vectors, right?
  Native vectors are of course heterogenous in Scheme.

  Can we write write a C-function that takes a =C_word=
  (representing a list somehow), and returns a =C_word= representing
  the R-object? RSPython has an optional translate thing. Should we
  force the user to package things as R-objects; or should we
  translate transparently? I'm loathe to do the latter; initial
  hypothesis, however?

  See [[file:/usr/local/src/chicken-4.7.0.6/chicken.h][chicken.h]] for things like =C_inline C_word C_a_i_list1(C_word
  **a, int n, C_word x1)=, which create lists;

  On [[http://cran.r-project.org/doc/manuals/R-exts.html#Garbage-Collection][PROTECT]]: they unprotect return before =return=. How much of the
  conversion can we do in Scheme? Seems more flexible that way.

  Is =C_c_pointer= useful for returning opaque R-objects, by the
  way? =C_pointer_to_object=?

  There's a [[file:/usr/local/lib64/R/include/Rinternals.h][reason]], incidentally, why things come up as both vectors
  and lists:

  #+BEGIN_SRC c
    #define IS_LIST(x)      IS_VECTOR(x)
  #+END_SRC

  How do we distinguish true lists from vectors? Maybe try the
  =Rf_isList=, =Rf_isPairList=, &c. from =Rinternals.h=.

  Here's the list:

  #+BEGIN_SRC c
    Rboolean Rf_isArray(SEXP);
    Rboolean Rf_isFactor(SEXP);
    Rboolean Rf_isFrame(SEXP);
    Rboolean Rf_isFunction(SEXP);
    Rboolean Rf_isInteger(SEXP);
    Rboolean Rf_isLanguage(SEXP);
    Rboolean Rf_isList(SEXP);
    Rboolean Rf_isMatrix(SEXP);
    Rboolean Rf_isNewList(SEXP);
    Rboolean Rf_isNumber(SEXP);
    Rboolean Rf_isNumeric(SEXP);
    Rboolean Rf_isPairList(SEXP);
    Rboolean Rf_isPrimitive(SEXP);
    Rboolean Rf_isTs(SEXP);
    Rboolean Rf_isUserBinop(SEXP);
    Rboolean Rf_isValidString(SEXP);
    Rboolean Rf_isValidStringF(SEXP);
    Rboolean Rf_isVector(SEXP);
    Rboolean Rf_isVectorAtomic(SEXP);
    Rboolean Rf_isVectorList(SEXP);
    Rboolean Rf_isVectorizable(SEXP);
  #+END_SRC

  Oh, yeah: there was that whole [[http://cran.r-project.org/doc/manuals/R-exts.html#Handling-lists][newList]] thing. Can we cherry-pick
  the things that have obvious Scheme counterparts

  From [[http://cran.r-project.org/doc/manuals/R-lang.html#Attributes][R-lang]]:

  #+BEGIN_QUOTE
  Matrices and arrays are simply vectors with the attribute dim and
  optionally dimnames attached to the vector.
  #+END_QUOTE

  [[http://cran.r-project.org/doc/manuals/R-lang.html#Factors][Factors]] sounds like enums:

  #+BEGIN_QUOTE
  Factors are currently implemented using an integer array to
  specify the actual levels and a second array of names that are
  mapped to the integers.
  #+END_QUOTE

  I wonder if =Rf_isFrame= applies to dataframes.

  This is cool, by the way; these guys dispatch on [[http://cran.r-project.org/doc/manuals/R-exts.html#Calling-_002eExternal][TYPEOF(el)]]:

  #+BEGIN_SRC c
    #include <R_ext/PrtUtil.h>

    SEXP showArgs(SEXP args)
    {
      args = CDR(args); /* skip 'name' */
      for(int i = 0; args != R_NilValue; i++, args = CDR(args)) {
        const char *name =
          isNull(TAG(args)) ? "" : CHAR(PRINTNAME(TAG(args)));
        SEXP el = CAR(args);
        if (length(el) == 0) {
          Rprintf("[%d] '%s' R type, length 0\n", i+1, name);
          continue;
        }
        switch(TYPEOF(el)) {
        case REALSXP:
          Rprintf("[%d] '%s' %f\n", i+1, name, REAL(el)[0]);
          break;
        case LGLSXP:
        case INTSXP:
          Rprintf("[%d] '%s' %d\n", i+1, name, INTEGER(el)[0]);
          break;
        case CPLXSXP:
          {
            Rcomplex cpl = COMPLEX(el)[0];
            Rprintf("[%d] '%s' %f + %fi\n", i+1, name, cpl.r, cpl.i);
          }
          break;
        case STRSXP:
          Rprintf("[%d] '%s' %s\n", i+1, name,
                  CHAR(STRING_ELT(el, 0)));
          break;
        default:
          Rprintf("[%d] '%s' R type\n", i+1, name);
        }
      }
      return(R_NilValue);
    }
  #+END_SRC

  Here's another list:

  #+BEGIN_SRC c
    #undef isNull
    #define isNull(s)   (TYPEOF(s) == NILSXP)
    #undef isSymbol
    #define isSymbol(s) (TYPEOF(s) == SYMSXP)
    #undef isLogical
    #define isLogical(s)    (TYPEOF(s) == LGLSXP)
    #undef isReal
    #define isReal(s)   (TYPEOF(s) == REALSXP)
    #undef isComplex
    #define isComplex(s)    (TYPEOF(s) == CPLXSXP)
    #undef isExpression
    #define isExpression(s) (TYPEOF(s) == EXPRSXP)
    #undef isEnvironment
    #define isEnvironment(s) (TYPEOF(s) == ENVSXP)
    #undef isString
    #define isString(s) (TYPEOF(s) == STRSXP)
    #undef isObject
    #define isObject(s) (OBJECT(s) != 0)
  #+END_SRC

  And yet another unadorned list:

  #+BEGIN_SRC c
    #define isArray         Rf_isArray
    #define isBasicClass            Rf_isBasicClass
    #define isComplex       Rf_isComplex
    #define isEnvironment       Rf_isEnvironment
    #define isExpression        Rf_isExpression
    #define isFactor        Rf_isFactor
    #define isFrame         Rf_isFrame
    #define isFree          Rf_isFree
    #define isFunction      Rf_isFunction
    #define isInteger       Rf_isInteger
    #define isLanguage      Rf_isLanguage
    #define isList          Rf_isList
    #define isLogical       Rf_isLogical
    #define isSymbol        Rf_isSymbol
    #define isMatrix        Rf_isMatrix
    #define isNewList       Rf_isNewList
    #define isNull          Rf_isNull
    #define isNumeric       Rf_isNumeric
    #define isNumber        Rf_isNumber
    #define isObject        Rf_isObject
    #define isOrdered       Rf_isOrdered
    #define isPairList      Rf_isPairList
    #define isPrimitive     Rf_isPrimitive
    #define isReal          Rf_isReal
    #define isS4            Rf_isS4
    #define isString        Rf_isString
    #define isTs            Rf_isTs
    #define isUnordered     Rf_isUnordered
    #define isUnsorted      Rf_isUnsorted
    #define isUserBinop     Rf_isUserBinop
    #define isValidString       Rf_isValidString
    #define isValidStringF      Rf_isValidStringF
    #define isVector        Rf_isVector
    #define isVectorAtomic      Rf_isVectorAtomic
    #define isVectorizable      Rf_isVectorizable
    #define isVectorList        Rf_isVectorList
  #+END_SRC

  Here's a list of SEXP-types that we could dispatch on via e.g.
  =switch= or some data-driven mechanism:

  #+BEGIN_SRC c
    #define NILSXP       0    /* nil = NULL */
    #define SYMSXP       1    /* symbols */
    #define LISTSXP      2    /* lists of dotted pairs */
    #define CLOSXP       3    /* closures */
    #define ENVSXP       4    /* environments */
    #define PROMSXP      5    /* promises: [un]evaluated closure arguments */
    #define LANGSXP      6    /* language constructs (special lists) */
    #define SPECIALSXP   7    /* special forms */
    #define BUILTINSXP   8    /* builtin non-special forms */
    #define CHARSXP      9    /* "scalar" string type (internal only)*/
    #define LGLSXP      10    /* logical vectors */
    #define INTSXP      13    /* integer vectors */
    #define REALSXP     14    /* real variables */
    #define CPLXSXP     15    /* complex variables */
    #define STRSXP      16    /* string vectors */
    #define DOTSXP      17    /* dot-dot-dot object */
    #define ANYSXP      18    /* make "any" args work.
                     Used in specifying types for symbol
                     registration to mean anything is okay  */
    #define VECSXP      19    /* generic vectors */
    #define EXPRSXP     20    /* expressions vectors */
    #define BCODESXP    21    /* byte code */
    #define EXTPTRSXP   22    /* external pointer */
    #define WEAKREFSXP  23    /* weak reference */
    #define RAWSXP      24    /* raw bytes */
    #define S4SXP       25    /* S4, non-vector */

    /* used for detecting PROTECT issues in memory.c */
    #define NEWSXP      30    /* fresh node creaed in new page */
    #define FREESXP     31    /* node released by GC */

    #define FUNSXP      99    /* Closure or Builtin or Special */
  #+END_SRC

  No, the whole fucking calculus in [[file:/usr/local/src/R/src/include/Rinlinedfuns.h][Rinlinedfuns.h]] regarding e.g.
  =isPairList= is relatively complex. Yeah; frame is dataframe, by
  the way:

  #+BEGIN_SRC c
    INLINE_FUN Rboolean isFrame(SEXP s)
    {   
      SEXP klass;
      int i;
      if (OBJECT(s)) {
        klass = getAttrib(s, R_ClassSymbol);
        for (i = 0; i < length(klass); i++)
          if (!strcmp(CHAR(STRING_ELT(klass, i)), "data.frame")) return TRUE;
      }
      return FALSE;
    }      
  #+END_SRC

  Levels can be symbols, can't they?

  Here's the difference between numeric and number:

  #+BEGIN_SRC c
    INLINE_FUN Rboolean isNumeric(SEXP s)
    {   
      switch(TYPEOF(s)) {
      case INTSXP:
        if (inherits(s,"factor")) return FALSE;
      case LGLSXP:
      case REALSXP:
        return TRUE;
      default:
        return FALSE;
      }
    }

    /** Is an object "Numeric" or  complex */
    INLINE_FUN Rboolean isNumber(SEXP s)
    {   
      switch(TYPEOF(s)) {
      case INTSXP:
        if (inherits(s,"factor")) return FALSE;
      case LGLSXP:
      case REALSXP:
      case CPLXSXP:
        return TRUE;
      default:
        return FALSE;
      }
    }
  #+END_SRC

  That's cool; they have scalar constructors:

  #+BEGIN_SRC c
    INLINE_FUN SEXP ScalarLogical(int x)
    {   
      SEXP ans = allocVector(LGLSXP, 1);
      if (x == NA_LOGICAL) LOGICAL(ans)[0] = NA_LOGICAL;
      else LOGICAL(ans)[0] = (x != 0);
      return ans;
    }
  #+END_SRC

  Making a named vector:

  #+BEGIN_SRC c
    /**
     * Create a named vector of type TYP
     *
     * @example const char *nms[] = {"xi", "yi", "zi", ""};
     *          mkNamed(VECSXP, nms);  =~= R  list(xi=, yi=, zi=)
     *
     * @param TYP a vector SEXP type (e.g. REALSXP)
     * @param names names of list elements with null string appended
     *
     * @return (pointer to a) named vector of type TYP
     */
    INLINE_FUN SEXP mkNamed(SEXPTYPE TYP, const char **names)
    {   
      SEXP ans, nms;
      int i, n;

      for (n = 0; strlen(names[n]) > 0; n++) {}
      ans = PROTECT(allocVector(TYP, n));
      nms = PROTECT(allocVector(STRSXP, n));
      for (i = 0; i < n; i++)
        SET_STRING_ELT(nms, i, mkChar(names[i]));
      setAttrib(ans, R_NamesSymbol, nms);
      UNPROTECT(2);
      return ans;
    }      
  #+END_SRC

  Making strings:

  #+BEGIN_SRC c
    /* short cut for  ScalarString(mkChar(s)) : */
    INLINE_FUN SEXP mkString(const char *s)
    {   
      SEXP t;

      PROTECT(t = allocVector(STRSXP, 1));
      SET_STRING_ELT(t, 0, mkChar(s));
      UNPROTECT(1);
      return t;
    }      
  #+END_SRC

  More basic tests:

  #+BEGIN_SRC c
    Rboolean (Rf_isNull)(SEXP s);
    Rboolean (Rf_isSymbol)(SEXP s);
    Rboolean (Rf_isLogical)(SEXP s);
    Rboolean (Rf_isReal)(SEXP s);
    Rboolean (Rf_isComplex)(SEXP s);
    Rboolean (Rf_isExpression)(SEXP s);
    Rboolean (Rf_isEnvironment)(SEXP s);
    Rboolean (Rf_isString)(SEXP s);
    Rboolean (Rf_isObject)(SEXP s);
  #+END_SRC

  [[http://www.jetcafe.org/jim/c-style.html#Naming][Funny]]:

  #+BEGIN_QUOTE
  In short, follow "Mike's Rule" to make variable name size
  proportional to scope:
  #+BEGIN_EXAMPLE
  length(name(variable)) ~ log(countlines(scope(variable)))
  #+END_EXAMPLE
  #+END_QUOTE

  Need an =Rvalue=, =Rfind=, or =Rget= to look up variables in a
  given environment (default to e.g. =R_GlobalEnv=).

  [[http://api.call-cc.org/doc/cairo][Cairo]] is replete with instances of allocating f64-vectors for e.g.
  pointers in Scheme before descending into C. We could probably do
  that before-hand, since we know the arguments; not necessarily the
  size, though? Sure: if we do the translation from within Scheme.
  Nursery takes care of garbage collection, I believe.

  #+BEGIN_SRC scheme :tangle minimal-segv.scm
    (use debug
         miscmacros)

    (define (give-me-some-shit)
      ((foreign-primitive
        scheme-object
        ()
        "C_word *value = C_alloc(C_SIZEOF_FLONUM);"
        "return(C_flonum(&value, 1.234));")))

    (dotimes (i 100000)
      (debug (give-me-some-shit)))      
  #+END_SRC

  Is [[http://paste.call-cc.org/pasteid%3Dd91e9ef5c6f671e7d20b408ea9144cacc1fbae47][this]] interesting? I like [[file:/usr/local/src/chicken-eggs/s11n/trunk/s11n-c.c][s11n-c.c]]. What's the equivalent of
  symbols in R, by the way?

  Disjoint predicates in Scheme:

  - boolean?
  - symbol?
  - char?
  - vector?
  - procedure?
  - pair?
  - number?
  - string?
  - port?

  How many of them can we support without trickery? Yet to do: char,
  pair, symbol, vector.

  To return opaque pointers, do we need =C_pointer_to_object=? How
  do we tag it? =C_taggedmpointer=, =C_taggedmpointer_or_false=.
  =C_make_pointer=, =C_make_tagged_pointer=. Shit: they're CPS.

  [[https://groups.google.com/d/msg/julia-dev/p5R7_xo7sRE/VnC6ZoCv-OUJ][Length vs. truelength]]; [[http://r.789695.n4.nabble.com/R-PreserveObject-R-ReleaseObject-reference-counting-needed-td997167.html][R_PreserveObject and R_ReleaseObject]]. We
  might have to use them.

  [[file:/usr/local/src/R/src/main/bind.c][Vector-type calculus]]:

  #+BEGIN_SRC c
    SEXP attribute_hidden do_c_dflt(SEXP call, SEXP op, SEXP args, SEXP env)
    {
      SEXP ans, t;
      int mode, recurse, usenames;
      struct BindData data;
      struct NameData nameData;

      /*    data.deparse_level = 1;  Initialize this early. */

      /* Method dispatch has failed; run the default code. */
      /* By default we do not recurse, but this can be over-ridden */
      /* by an optional "recursive" argument. */

      usenames = 1;
      recurse = 0;
      /* this was only done for length(args) > 1 prior to 1.5.0,
         _but_ `recursive' might be the only argument */
      PROTECT(args = ExtractOptionals(args, &recurse, &usenames, call));

      /* Determine the type of the returned value. */
      /* The strategy here is appropriate because the */
      /* object being operated on is a pair based list. */

      data.ans_flags  = 0;
      data.ans_length = 0;
      data.ans_nnames = 0;

      for (t = args; t != R_NilValue; t = CDR(t)) {
        if (usenames && !data.ans_nnames) {
          if (!isNull(TAG(t))) data.ans_nnames = 1;
          else data.ans_nnames = HasNames(CAR(t));
        }
        AnswerType(CAR(t), recurse, usenames, &data);
      }

      /* If a non-vector argument was encountered (perhaps a list if */
      /* recursive is FALSE) then we must return a list.    Otherwise, */
      /* we use the natural coercion for vector types. */

      mode = NILSXP;
      if (data.ans_flags & 512)    mode = EXPRSXP;
      else if (data.ans_flags & 256) mode = VECSXP;
      else if (data.ans_flags & 128) mode = STRSXP;
      else if (data.ans_flags &  64) mode = CPLXSXP;
      else if (data.ans_flags &  32) mode = REALSXP;
      else if (data.ans_flags &  16) mode = INTSXP;
      else if (data.ans_flags & 2) mode = LGLSXP;
      else if (data.ans_flags & 1) mode = RAWSXP;

      /* Allocate the return value and set up to pass through */
      /* the arguments filling in values of the returned object. */

      PROTECT(ans = allocVector(mode, data.ans_length));
      data.ans_ptr = ans;
      data.ans_length = 0;
      t = args;

      if (mode == VECSXP || mode == EXPRSXP) {
        if (!recurse) {
          while (args != R_NilValue) {
            ListAnswer(CAR(args), 0, &data, call);
            args = CDR(args);
          }
        }
        else ListAnswer(args, recurse, &data, call);
        data.ans_length = length(ans);
      }
      else if (mode == STRSXP)
        StringAnswer(args, &data, call);
      else if (mode == CPLXSXP)
        ComplexAnswer(args, &data, call);
      else if (mode == REALSXP)
        RealAnswer(args, &data, call);
      else if (mode == RAWSXP)
        RawAnswer(args, &data, call);
      else if (mode == LGLSXP)
        LogicalAnswer(args, &data, call);
      else /* integer */
        IntegerAnswer(args, &data, call);
      args = t;

      /* Build and attach the names attribute for the returned object. */

      if (data.ans_nnames && data.ans_length > 0) {
        PROTECT(data.ans_names = allocVector(STRSXP, data.ans_length));
        data.ans_nnames = 0;
        while (args != R_NilValue) {
          nameData.seqno = 0;
          nameData.firstpos = 0;
          nameData.count = 0;
          NewExtractNames(CAR(args), R_NilValue, TAG(args), recurse, &data, &nameData);
          args = CDR(args);
        }
        setAttrib(ans, R_NamesSymbol, data.ans_names);
        UNPROTECT(1);
      }
      UNPROTECT(2);
      R_FreeStringBufferL(&cbuff);
      return ans;
    } /* do_c */

  #+END_SRC
** On [[http://cran.r-project.org/doc/manuals/R-exts.html#Handling-lists][lists]]
   #+BEGIN_QUOTE
   List elements can be retrieved or set by direct access to the
   elements of the generic vector. Suppose we have a list object a
   <- list(f = 1, g = 2, h = 3)

   Then we can access a$g as =a[[2]]= by 
   #+BEGIN_SRC c
     double g;
     ....
     g = REAL(VECTOR_ELT(a, 1))[0];
   #+END_SRC

   This can rapidly become tedious, and the following function
   (based on one in package stats) is very useful:

   #+BEGIN_SRC c
     /* get the list element named str, or return NULL */

     SEXP getListElement(SEXP list, const char *str)
     {
       SEXP elmt = R_NilValue, names = getAttrib(list,
                                                 R_NamesSymbol);

       for (R_len_t i = 0; i < length(list); i++)
         if(strcmp(CHAR(STRING_ELT(names, i)), str) == 0) {
           elmt = VECTOR_ELT(list, i);
           break;
         }
       return elmt;
     }
   #+END_SRC

   and enables us to say 

   #+BEGIN_SRC c
     double g;
     g = REAL(getListElement(a, "g"))[0];
   #+END_SRC
   #+END_QUOTE
** Finding [[http://cran.r-project.org/doc/manuals/R-exts.html#Finding-and-setting-variables][variables]]
   #+BEGIN_SRC c
     SEXP getvar(SEXP name, SEXP rho)
     {
       SEXP ans;

       if(!isString(name) || length(name) != 1)
         error("name is not a single string");
       if(!isEnvironment(rho))
         error("rho should be an environment");
       ans = findVar(install(CHAR(STRING_ELT(name, 0))), rho);
       Rprintf("first value is %f\n", REAL(ans)[0]);
       return(R_NilValue);
     }
   #+END_SRC

   #+BEGIN_SRC c
     void defineVar(SEXP symbol, SEXP value, SEXP rho);
     void setVar(SEXP symbol, SEXP value, SEXP rho);
   #+END_SRC
** [[http://cran.r-project.org/doc/manuals/R-exts.html#Named-objects-and-copying][Copying]] objects
   #+BEGIN_QUOTE
   It is safe to modify the value of any SEXP for which NAMED(foo)
   is zero, and if NAMED(foo) is two, the value should be duplicated
   (via a call to duplicate) before any modification. Note that it
   is the responsibility of the author of the code making the
   modification to do the duplication, even if it is x whose value
   is being modified after y <- x.
   #+END_QUOTE
** [[http://cran.r-project.org/doc/manuals/R-exts.html#Evaluating-R-expressions-from-C][Evaluating]] R expressions
   #+BEGIN_SRC c
     SEXP lapply(SEXP list, SEXP expr, SEXP rho)
     {
       R_len_t i, n = length(list);
       SEXP ans;

       if(!isNewList(list)) error("'list' must be a list");
       if(!isEnvironment(rho)) error("'rho' should be an environment");
       PROTECT(ans = allocVector(VECSXP, n));
       for(i = 0; i < n; i++) {
         defineVar(install("x"), VECTOR_ELT(list, i), rho);
         SET_VECTOR_ELT(ans, i, eval(expr, rho));
       }
       setAttrib(ans, R_NamesSymbol, getAttrib(list, R_NamesSymbol));
       UNPROTECT(1);
       return(ans);
     }
   #+END_SRC

   Protects a SEXP =ans= to return; this constructs a functions via
   =lang2=:

   #+BEGIN_SRC c
     SEXP lapply2(SEXP list, SEXP fn, SEXP rho)
     {
       R_len_t i, n = length(list);
       SEXP R_fcall, ans;

       if(!isNewList(list)) error("'list' must be a list");
       if(!isFunction(fn)) error("'fn' must be a function");
       if(!isEnvironment(rho)) error("'rho' should be an environment");
       PROTECT(R_fcall = lang2(fn, R_NilValue));
       PROTECT(ans = allocVector(VECSXP, n));
       for(i = 0; i < n; i++) {
         SETCADR(R_fcall, VECTOR_ELT(list, i));
         SET_VECTOR_ELT(ans, i, eval(R_fcall, rho));
       }
       setAttrib(ans, R_NamesSymbol, getAttrib(list, R_NamesSymbol));
       UNPROTECT(2);
       return(ans);
     }
   #+END_SRC
** [[http://cran.r-project.org/doc/manuals/R-exts.html#Zero_002dfinding][Zero]] finding
   #+BEGIN_SRC c
     SEXP mkans(double x)
     {
       SEXP ans;
       PROTECT(ans = allocVector(REALSXP, 1));
       REAL(ans)[0] = x;
       UNPROTECT(1);
       return ans;
     }

     double feval(double x, SEXP f, SEXP rho)
     {
       defineVar(install("x"), mkans(x), rho);
       return(REAL(eval(f, rho))[0]);
     }

     SEXP zero(SEXP f, SEXP guesses, SEXP stol, SEXP rho)
     {
       double x0 = REAL(guesses)[0], x1 = REAL(guesses)[1],
         tol = REAL(stol)[0];
       double f0, f1, fc, xc;

       if(tol <= 0.0) error("non-positive tol value");
       f0 = feval(x0, f, rho); f1 = feval(x1, f, rho);
       if(f0 == 0.0) return mkans(x0);
       if(f1 == 0.0) return mkans(x1);
       if(f0*f1 > 0.0) error("x[0] and x[1] have the same sign");

       for(;;) {
         xc = 0.5*(x0+x1);
         if(fabs(x0-x1) < tol) return  mkans(xc);
         fc = feval(xc, f, rho);
         if(fc == 0) return  mkans(xc);
         if(f0*fc > 0.0) {
           x0 = xc; f0 = fc;
         } else {
           x1 = xc; f1 = fc;
         }
       }
     }
   #+END_SRC

   Good stuff in there with =mkans=.
** [[http://cran.r-project.org/doc/manuals/R-exts.html#Parsing-R-code-from-C][Parsing]] R
   #+BEGIN_SRC c
          #include <R.h>
          #include <Rinternals.h>
          #include <R_ext/Parse.h>

     SEXP menu_ttest3()
     {
       char cmd[256];
       SEXP cmdSexp, cmdexpr, ans = R_NilValue;
       ParseStatus status;
             ...
         if(done == 1) {
           PROTECT(cmdSexp = allocVector(STRSXP, 1));
           SET_STRING_ELT(cmdSexp, 0, mkChar(cmd));
           cmdexpr = PROTECT(R_ParseVector(cmdSexp, -1, &status, R_NilValue));
           if (status != PARSE_OK) {
             UNPROTECT(2);
             error("invalid call %s", cmd);
           }
           /* Loop is needed here as EXPSEXP will be of length > 1 */
           for(R_len_t i = 0; i < length(cmdexpr); i++)
             ans = eval(VECTOR_ELT(cmdexpr, i), R_GlobalEnv);
           UNPROTECT(2);
         }
         return ans;
     }
   #+END_SRC
** [[http://cran.r-project.org/doc/manuals/R-exts.html#Printing][Printing]]
   #+BEGIN_QUOTE
   The most useful function for printing from a C routine compiled
   into R is Rprintf. This is used in exactly the same way as
   printf, but is guaranteed to write to R's output (which might be
   a GUI console rather than a file, and can be re-directed by
   sink). It is wise to write complete lines (including the "\n")
   before returning to R. It is defined in R_ext/Print.h. 

   The function REprintf is similar but writes on the error stream
   (stderr) which may or may not be different from the standard
   output stream. 

   Functions Rvprintf and REvprintf are analogues using the vprintf
   interface. Because that is a C99 interface, they are only defined
   by R_ext/Print.h in C++ code if the macro R_USE_C99_IN_CXX is
   defined when it is included.
   #+END_QUOTE

   Hence, we can define [[http://cran.r-project.org/doc/manuals/R-exts.html#Setting-R-callbacks][callbacks]] like e.g.:

   #+BEGIN_SRC c
     extern void (*ptr_R_WriteConsole)(const char *, int);
   #+END_SRC

   I vaguely remember doing this for rJava.
** The [[http://cran.r-project.org/doc/manuals/R-exts.html#Organization-of-header-files][headers]]
* TODO Initialization function
  Isn't it a little rude to initialize on =use=?
* TODO Parse positional and keyword arguments.
  Iterate with a little state machine: last keyword seen, &c. Two
  lists: keyword and positional lists. Pass them to C.
* TODO Do less in C, more in Scheme.
# <<less-in-c>>
  Maybe we can avoid some of the bizarre memory corruptions when we
  tried to e.g. procedurize =to_scheme=.

  It should be trivial to do things like allocate vectors.

  Is it also possible to use some sort of Chicken-destructor to call
  things like e.g. =R_ReleaseObject=? That would be fucking fantastic.
* TODO Tests
* TODO =R-value= or =R-get=
  which is really just a wrapper around =Reval= that calls =get=,
  isn't it; with optional =rho= (environment)?
* TODO Simply =eval= and =get=; allow the user to prefix on import?
  Seems like a shitty thing to have to do by default.

* TODO Recursive =to_scheme=
  Possibly related to [[less-in-c]]?
